"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFieldWireType = exports.isManagedFieldType = exports.isNullableFieldType = exports.generateFieldTypeInstruction = exports.generateFieldDefaultValue = exports.generateFieldType = exports.generateFieldTypeBasic = exports.generateFieldName = exports.generateFieldDecodeInstruction = exports.generateFieldEncodeInstruction = void 0;
const descriptor_pb_1 = require("google-protobuf/google/protobuf/descriptor_pb");
const assert = __importStar(require("assert"));
const humps_1 = require("humps");
const ref_1 = require("./ref");
var Type = descriptor_pb_1.FieldDescriptorProto.Type;
var Label = descriptor_pb_1.FieldDescriptorProto.Label;
function generateFieldEncodeInstruction(fieldDescriptor, scopeContext) {
    const isRepeated = fieldDescriptor.getLabel() === Label.LABEL_REPEATED;
    const isMessage = fieldDescriptor.getType() === Type.TYPE_MESSAGE;
    const isPacked = fieldDescriptor.getOptions()?.hasPacked();
    const fieldTag = getFieldTag(fieldDescriptor);
    const fieldName = generateFieldName(fieldDescriptor);
    const fieldVariable = scopeContext.registerName(fieldName);
    const encodeInstruction = (variable, descriptor = fieldDescriptor) => {
        const isMessage = descriptor.getType() === Type.TYPE_MESSAGE;
        if (isMessage) {
            const Message = (0, ref_1.generateRef)(descriptor, scopeContext.getFileContext());
            return `${Message}.encode(${variable}, writer)`;
        }
        else {
            const fieldTypeInstruction = generateFieldTypeInstruction(descriptor);
            return `writer.${fieldTypeInstruction}(${variable})`;
        }
    };
    const forkInstruction = (code, shouldFork = true) => {
        if (!shouldFork) {
            return code;
        }
        return [`writer.fork();`, code.trim(), `writer.ldelim();`].join("\n");
    };
    if (isMessage) {
        const messageDescriptor = getFieldMessageDescriptor(fieldDescriptor, scopeContext.getFileContext().getGeneratorContext());
        assert.ok(messageDescriptor);
        const isMap = isMapMessageDescriptor(messageDescriptor);
        if (isMap) {
            const keysVariable = scopeContext.registerName(fieldName + "Keys");
            const keyVariable = scopeContext.registerName(fieldName + "Key");
            const [keyDescriptor, valueDescriptor] = getMapKeyAndValueFieldDescriptors(messageDescriptor);
            const keyTag = getFieldTag(keyDescriptor);
            const valueTag = getFieldTag(valueDescriptor);
            const isValueMessage = valueDescriptor.getType() === Type.TYPE_MESSAGE;
            return `
        const ${fieldVariable} = message.${fieldName};
        if (${fieldVariable} !== null) {
          const ${keysVariable} = ${fieldVariable}.keys();
          for (let i: i32 = 0; i < ${keysVariable}.length; ++i) {
            const ${keyVariable} = ${keysVariable}[i];
            writer.uint32(${fieldTag});
            ${forkInstruction(`
              writer.uint32(${keyTag});
              ${encodeInstruction(keyVariable, keyDescriptor)};
              writer.uint32(${valueTag});
              ${forkInstruction(`${encodeInstruction(`${fieldVariable}.get(${keyVariable})`, valueDescriptor)};`, isValueMessage)}
            `)}
          }
        }
      `;
        }
        else if (isRepeated && isPacked) {
            return `
        const ${fieldVariable} = message.${fieldName};
        writer.uint32(${fieldTag});
        ${forkInstruction(`
          for (let i: i32 = 0; i < ${fieldVariable}.length; ++i) {
            ${encodeInstruction(`${fieldVariable}[i]`)};
          }
        `)}
      `;
        }
        else if (isRepeated) {
            return `
        const ${fieldVariable} = message.${fieldName};
        for (let i: i32 = 0; i < ${fieldVariable}.length; ++i) {
          writer.uint32(${fieldTag});
          ${forkInstruction(`${encodeInstruction(`${fieldVariable}[i]`)};`)}
        }
      `;
        }
        else {
            return `
        const ${fieldVariable} = message.${fieldName};
        if (${fieldVariable} !== null) {
          writer.uint32(${fieldTag});
          ${forkInstruction(`${encodeInstruction(fieldVariable)};`)}
        }
      `;
        }
    }
    else {
        if (isRepeated && isPacked) {
            return `
        const ${fieldVariable} = message.${fieldName};
        if (${fieldVariable}.length !== 0) {
          writer.uint32(${fieldTag});
          ${forkInstruction(`
            for (let i: i32 = 0; i < ${fieldVariable}.length; ++i) {
              ${encodeInstruction(`${fieldVariable}[i]`)};
            }
          `)}
        }
      `;
        }
        else if (isRepeated) {
            return `
        const ${fieldVariable} = message.${fieldName};
        if (${fieldVariable}.length !== 0) {
          for (let i: i32 = 0; i < ${fieldVariable}.length; ++i) {
            writer.uint32(${fieldTag});
            ${encodeInstruction(`${fieldVariable}[i]`)};
          }
        }
      `;
        }
        else if (isNullableFieldType(fieldDescriptor)) {
            return `
        const ${fieldVariable} = message.${fieldName};
        if (${fieldVariable} !== null) {
          writer.uint32(${fieldTag});
          ${encodeInstruction(fieldVariable)};
        }
      `;
        }
        else {
            return `
        writer.uint32(${fieldTag});
        ${encodeInstruction(`message.${fieldName}`)};
      `;
        }
    }
}
exports.generateFieldEncodeInstruction = generateFieldEncodeInstruction;
function generateFieldDecodeInstruction(fieldDescriptor, scopeContext) {
    const isRepeated = fieldDescriptor.getLabel() === Label.LABEL_REPEATED;
    const isMessage = fieldDescriptor.getType() === Type.TYPE_MESSAGE;
    const isPacked = fieldDescriptor.getOptions()?.hasPacked();
    const fieldNumber = fieldDescriptor.getNumber();
    assert.ok(fieldNumber !== undefined);
    const fieldName = generateFieldName(fieldDescriptor);
    const decodeInstruction = (descriptor = fieldDescriptor) => {
        const isMessage = descriptor.getType() === Type.TYPE_MESSAGE;
        if (isMessage) {
            const Message = (0, ref_1.generateRef)(descriptor, scopeContext.getFileContext());
            return `${Message}.decode(reader, reader.uint32())`;
        }
        else {
            const fieldTypeInstruction = generateFieldTypeInstruction(descriptor);
            return `reader.${fieldTypeInstruction}()`;
        }
    };
    if (isMessage) {
        const messageDescriptor = getFieldMessageDescriptor(fieldDescriptor, scopeContext.getFileContext().getGeneratorContext());
        assert.ok(messageDescriptor);
        const isMap = isMapMessageDescriptor(messageDescriptor);
        if (isMap) {
            const [keyDescriptor, valueDescriptor] = getMapKeyAndValueFieldDescriptors(messageDescriptor);
            const keyTypeBasic = generateFieldTypeBasic(keyDescriptor, scopeContext.getFileContext());
            const keyType = generateFieldType(keyDescriptor, scopeContext.getFileContext());
            const valueTypeBasic = generateFieldTypeBasic(valueDescriptor, scopeContext.getFileContext());
            const valueType = generateFieldType(valueDescriptor, scopeContext.getFileContext());
            const fieldVariable = scopeContext.registerName(fieldName);
            const keyVariable = scopeContext.registerName(fieldName + "Key");
            const hasKeyVariable = scopeContext.registerName(fieldName + "HasKey");
            const valueVariable = scopeContext.registerName(fieldName + "Value");
            const hasValueVariable = scopeContext.registerName(fieldName + "HasValue");
            const keyNumber = keyDescriptor.getNumber();
            const valueNumber = valueDescriptor.getNumber();
            const keyDefaultValue = generateFieldBasicDefaultValue(keyDescriptor);
            const valueDefaultValue = generateFieldBasicDefaultValue(valueDescriptor);
            const keyDecodeInstruction = decodeInstruction(keyDescriptor);
            const valueDecodeInstruction = decodeInstruction(valueDescriptor);
            const setMapConditions = [
                `${fieldVariable} !== null`,
                hasKeyVariable,
                hasValueVariable,
            ];
            if (isNullableFieldType(keyDescriptor)) {
                setMapConditions.push(`${keyVariable} !== null`);
            }
            if (isNullableFieldType(valueDescriptor)) {
                setMapConditions.push(`${valueVariable} !== null`);
            }
            return `
        case ${fieldNumber}:
          let ${keyVariable}: ${keyType} = ${keyDefaultValue};
          let ${valueVariable}: ${valueType} = ${valueDefaultValue};
          let ${hasKeyVariable}: bool = false;
          let ${hasValueVariable}: bool = false;
          for (const end: usize = reader.ptr + reader.uint32(); reader.ptr < end;) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
              case ${keyNumber}:
                ${keyVariable} = ${keyDecodeInstruction};
                ${hasKeyVariable} = true;
                break;
                
              case ${valueNumber}:
                ${valueVariable} = ${valueDecodeInstruction};
                ${hasValueVariable} = true;
                break;

              default:
                reader.skipType(tag & 7);
                break;
            }
            if (message.${fieldName} === null) {
              message.${fieldName} = new Map<${keyTypeBasic}, ${valueTypeBasic}>();
            }
            const ${fieldVariable} = message.${fieldName};
            if (${setMapConditions.join(" && ")}) {
              ${fieldVariable}.set(${keyVariable}, ${valueVariable});
            }
          }
          break;
      `;
        }
        else if (isRepeated && isPacked) {
            return `
        case ${fieldNumber}:
          for (const end: usize = reader.ptr + reader.uint32(); reader.ptr < end;) {
            message.${fieldName}.push(${decodeInstruction()});
          }
          break;
      `;
        }
        else if (isRepeated) {
            return `
        case ${fieldNumber}:
          message.${fieldName}.push(${decodeInstruction()});
          break;
      `;
        }
        else {
            return `
        case ${fieldNumber}:
          message.${fieldName} = ${decodeInstruction()};
          break;
      `;
        }
    }
    else {
        if (isRepeated && isPacked) {
            return `
        case ${fieldNumber}:
          for (const end: usize = reader.ptr + reader.uint32(); reader.ptr < end;) {
            message.${fieldName}.push(${decodeInstruction()});
          }
          break;
      `;
        }
        else if (isRepeated) {
            return `
        case ${fieldNumber}:
          message.${fieldName}.push(${decodeInstruction()});
          break;
      `;
        }
        else {
            return `
        case ${fieldNumber}:
          message.${fieldName} = ${decodeInstruction()};
          break;
      `;
        }
    }
}
exports.generateFieldDecodeInstruction = generateFieldDecodeInstruction;
function generateFieldName(fieldDescriptor) {
    const fieldName = fieldDescriptor.getName();
    assert.ok(fieldName);
    return (0, humps_1.camelize)(fieldName);
}
exports.generateFieldName = generateFieldName;
function generateFieldTypeBasic(fieldDescriptor, fileContext) {
    switch (fieldDescriptor.getType()) {
        case Type.TYPE_INT32:
        case Type.TYPE_SINT32:
        case Type.TYPE_FIXED32:
        case Type.TYPE_SFIXED32:
            return "i32";
        case Type.TYPE_UINT32:
            return "u32";
        case Type.TYPE_INT64:
        case Type.TYPE_SINT64:
        case Type.TYPE_FIXED64:
        case Type.TYPE_SFIXED64:
            return "i64";
        case Type.TYPE_UINT64:
            return "u64";
        case Type.TYPE_FLOAT:
            return "f32";
        case Type.TYPE_DOUBLE:
            return "f64";
        case Type.TYPE_BOOL:
            return "bool";
        case Type.TYPE_STRING:
            return "string";
        case Type.TYPE_BYTES:
            return "Uint8Array";
        case Type.TYPE_MESSAGE: {
            const messageDescriptor = getFieldMessageDescriptor(fieldDescriptor, fileContext.getGeneratorContext());
            const isMap = messageDescriptor && isMapMessageDescriptor(messageDescriptor);
            if (isMap) {
                const [keyFieldDescriptor, valueFieldDescriptor] = getMapKeyAndValueFieldDescriptors(messageDescriptor);
                return `Map<${generateFieldTypeBasic(keyFieldDescriptor, fileContext)}, ${generateFieldTypeBasic(valueFieldDescriptor, fileContext)}>`;
            }
            else {
                return (0, ref_1.generateRef)(fieldDescriptor, fileContext);
            }
        }
        case Type.TYPE_ENUM:
            return (0, ref_1.generateRef)(fieldDescriptor, fileContext);
        default:
            throw new Error(`Type "${fieldDescriptor.getTypeName()}" is not supported by as-proto-gen`);
    }
}
exports.generateFieldTypeBasic = generateFieldTypeBasic;
function generateFieldType(fieldDescriptor, fileContext) {
    const isRepeated = fieldDescriptor.getLabel() === Label.LABEL_REPEATED;
    const isMap = isMapFieldDescriptor(fieldDescriptor, fileContext.getGeneratorContext());
    let typeCode = generateFieldTypeBasic(fieldDescriptor, fileContext);
    if (isRepeated && !isMap) {
        typeCode = `Array<${typeCode}>`;
    }
    else if (isNullableFieldType(fieldDescriptor) && !isMap) {
        typeCode = `${typeCode} | null`;
    }
    return typeCode;
}
exports.generateFieldType = generateFieldType;
function generateFieldDefaultValue(fieldDescriptor, fileContext) {
    const isRepeated = fieldDescriptor.getLabel() === Label.LABEL_REPEATED;
    const isMap = isMapFieldDescriptor(fieldDescriptor, fileContext.getGeneratorContext());
    const defaultValue = fieldDescriptor.getDefaultValue();
    if (isMap) {
        return "new Map()";
    }
    else if (isRepeated) {
        return "[]";
    }
    else if (defaultValue) {
        switch (fieldDescriptor.getType()) {
            case Type.TYPE_INT32:
            case Type.TYPE_SINT32:
            case Type.TYPE_FIXED32:
            case Type.TYPE_SFIXED32:
            case Type.TYPE_UINT32:
            case Type.TYPE_INT64:
            case Type.TYPE_SINT64:
            case Type.TYPE_FIXED64:
            case Type.TYPE_SFIXED64:
            case Type.TYPE_UINT64:
            case Type.TYPE_BOOL:
            case Type.TYPE_FLOAT:
            case Type.TYPE_DOUBLE:
                return defaultValue;
            case Type.TYPE_ENUM:
                return `${(0, ref_1.generateRef)(fieldDescriptor, fileContext)}.${defaultValue}`;
            case Type.TYPE_STRING:
                return JSON.stringify(defaultValue);
            case Type.TYPE_BYTES:
                // TODO: handle default value for bytes
                return "new Uint8Array(0)";
            case Type.TYPE_MESSAGE:
                return "null";
            default:
                throw new Error(`Type "${fieldDescriptor.getTypeName()}" (${fieldDescriptor.getType()}) is not supported by as-proto-gen`);
        }
    }
    else {
        return generateFieldBasicDefaultValue(fieldDescriptor);
    }
}
exports.generateFieldDefaultValue = generateFieldDefaultValue;
function generateFieldBasicDefaultValue(fieldDescriptor) {
    switch (fieldDescriptor.getType()) {
        case Type.TYPE_INT32:
        case Type.TYPE_SINT32:
        case Type.TYPE_FIXED32:
        case Type.TYPE_SFIXED32:
        case Type.TYPE_UINT32:
        case Type.TYPE_INT64:
        case Type.TYPE_SINT64:
        case Type.TYPE_FIXED64:
        case Type.TYPE_SFIXED64:
        case Type.TYPE_UINT64:
        case Type.TYPE_ENUM:
            return "0";
        case Type.TYPE_FLOAT:
        case Type.TYPE_DOUBLE:
            return "0.0";
        case Type.TYPE_BOOL:
            return "false";
        case Type.TYPE_STRING:
            return '""';
        case Type.TYPE_BYTES:
            return "new Uint8Array(0)";
        case Type.TYPE_MESSAGE:
            return "null";
        default:
            throw new Error(`Type "${fieldDescriptor.getTypeName()}" (${fieldDescriptor.getType()}) is not supported by as-proto-gen`);
    }
}
function generateFieldTypeInstruction(fieldDescriptor) {
    switch (fieldDescriptor.getType()) {
        case Type.TYPE_INT32:
            return "int32";
        case Type.TYPE_SINT32:
            return "sint32";
        case Type.TYPE_FIXED32:
            return "fixed32";
        case Type.TYPE_SFIXED32:
            return "sfixed32";
        case Type.TYPE_UINT32:
            return "uint32";
        case Type.TYPE_INT64:
            return "int64";
        case Type.TYPE_SINT64:
            return "sint64";
        case Type.TYPE_FIXED64:
            return "fixed64";
        case Type.TYPE_SFIXED64:
            return "sfixed64";
        case Type.TYPE_UINT64:
            return "uint64";
        case Type.TYPE_FLOAT:
            return "float";
        case Type.TYPE_DOUBLE:
            return "double";
        case Type.TYPE_BOOL:
            return "bool";
        case Type.TYPE_STRING:
            return "string";
        case Type.TYPE_BYTES:
            return "bytes";
        case Type.TYPE_ENUM:
            return "int32";
        case Type.TYPE_MESSAGE:
            return undefined;
        default:
            throw new Error(`Type "${fieldDescriptor.getTypeName()}" is not supported by as-proto-gen`);
    }
}
exports.generateFieldTypeInstruction = generateFieldTypeInstruction;
function isNullableFieldType(fieldDescriptor) {
    const fieldType = fieldDescriptor.getType();
    assert.ok(fieldType !== undefined);
    return fieldType === Type.TYPE_MESSAGE;
}
exports.isNullableFieldType = isNullableFieldType;
function isManagedFieldType(fieldDescriptor) {
    const fieldType = fieldDescriptor.getType();
    assert.ok(fieldType !== undefined);
    return (fieldType === Type.TYPE_MESSAGE ||
        fieldType === Type.TYPE_STRING ||
        fieldType === Type.TYPE_BYTES);
}
exports.isManagedFieldType = isManagedFieldType;
function getFieldWireType(fieldDescriptor) {
    const isRepeated = fieldDescriptor.getLabel() === Label.LABEL_REPEATED;
    const isPacked = fieldDescriptor.getOptions()?.hasPacked();
    if (isRepeated && isPacked) {
        return 2;
    }
    const fieldType = fieldDescriptor.getType();
    assert.ok(fieldType !== undefined);
    switch (fieldType) {
        case Type.TYPE_INT32:
        case Type.TYPE_UINT32:
        case Type.TYPE_SINT32:
        case Type.TYPE_INT64:
        case Type.TYPE_UINT64:
        case Type.TYPE_SINT64:
        case Type.TYPE_BOOL:
        case Type.TYPE_ENUM:
            return 0;
        case Type.TYPE_FIXED64:
        case Type.TYPE_SFIXED64:
        case Type.TYPE_DOUBLE:
            return 1;
        case Type.TYPE_FIXED32:
        case Type.TYPE_SFIXED32:
        case Type.TYPE_FLOAT:
            return 5;
        case Type.TYPE_STRING:
        case Type.TYPE_BYTES:
        case Type.TYPE_MESSAGE:
            return 2;
        default:
            throw new Error("Invalid type " + fieldType);
    }
}
exports.getFieldWireType = getFieldWireType;
function getFieldTag(fieldDescriptor) {
    const fieldNumber = fieldDescriptor.getNumber();
    assert.ok(fieldNumber !== undefined);
    return (fieldNumber << 3) | getFieldWireType(fieldDescriptor);
}
function getFieldMessageDescriptor(fieldDescriptor, generatorContext) {
    assert.ok(fieldDescriptor.getType() === Type.TYPE_MESSAGE);
    const fieldTypeName = fieldDescriptor.getTypeName();
    assert.ok(fieldTypeName !== undefined);
    return generatorContext.getMessageDescriptorByFieldTypeName(fieldTypeName);
}
function isMapMessageDescriptor(messageDescriptor) {
    return messageDescriptor.getOptions()?.getMapEntry() || false;
}
function isMapFieldDescriptor(fieldDescriptor, generatorContext) {
    if (fieldDescriptor.getType() !== Type.TYPE_MESSAGE ||
        fieldDescriptor.getLabel() !== Label.LABEL_REPEATED) {
        return false;
    }
    const messageDescriptor = getFieldMessageDescriptor(fieldDescriptor, generatorContext);
    return messageDescriptor ? isMapMessageDescriptor(messageDescriptor) : false;
}
function getMapKeyAndValueFieldDescriptors(messageDescriptor) {
    const [keyFieldDescriptor, valueFieldDescriptor] = messageDescriptor.getFieldList();
    assert.ok(keyFieldDescriptor !== undefined);
    assert.ok(valueFieldDescriptor !== undefined);
    return [keyFieldDescriptor, valueFieldDescriptor];
}
