"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateMessage = void 0;
const field_1 = require("./field");
const assert = __importStar(require("assert"));
const scope_context_1 = require("../scope-context");
const reserved_keywords_1 = require("../reserved-keywords");
function generateMessage(messageDescriptor, fileContext, compilerOptions) {
    const messageName = messageDescriptor.getName();
    assert.ok(messageName);
    const Message = fileContext.registerDefinition(messageName);
    if (compilerOptions.has("gen-helper-methods")) {
        // reserve these names
        fileContext.registerDefinition(`encode${Message}`);
        fileContext.registerDefinition(`decode${Message}`);
    }
    const MessageClass = `
    export class ${Message} {
      ${generateEncodeMethod(messageDescriptor, fileContext)}
      ${generateDecodeMethod(messageDescriptor, fileContext)}

      ${generateMessageFieldsDeclarations(messageDescriptor, fileContext)}

      ${generateMessageConstructor(messageDescriptor, fileContext)}
    }
  `;
    const parts = [MessageClass];
    if (compilerOptions.has("gen-helper-methods")) {
        parts.push(generateHelperMethods(Message, fileContext));
    }
    return parts.join("\n");
}
exports.generateMessage = generateMessage;
function getAllFields(messageDescriptor) {
    return [
        ...messageDescriptor.getFieldList(),
        ...messageDescriptor.getExtensionList(),
    ];
}
function generateEncodeMethod(messageDescriptor, fileContext) {
    const messageName = messageDescriptor.getName();
    assert.ok(messageName);
    const fields = getAllFields(messageDescriptor);
    const Writer = fileContext.registerImport("Writer", "as-proto/assembly");
    const Message = fileContext.registerDefinition(messageName);
    const scopeContext = new scope_context_1.ScopeContext(fileContext, ["message", "writer"]);
    return `
    static encode(message: ${Message}, writer: ${Writer}): void {
      ${fields
        .map((fieldDescriptor) => `${(0, field_1.generateFieldEncodeInstruction)(fieldDescriptor, scopeContext)}`)
        .join("\n")}
    }
  `;
}
function generateDecodeMethod(messageDescriptor, fileContext) {
    const messageName = messageDescriptor.getName();
    assert.ok(messageName);
    const fields = getAllFields(messageDescriptor);
    const Reader = fileContext.registerImport("Reader", "as-proto/assembly");
    const Message = fileContext.registerDefinition(messageName);
    const scopeContext = new scope_context_1.ScopeContext(fileContext, [
        "reader",
        "length",
        "end",
        "message",
        "tag",
    ]);
    return `
    static decode(reader: ${Reader}, length: i32): ${Message} {
      const end: usize = length < 0 ? reader.end : reader.ptr + length;
      const message = new ${Message}();

      while (reader.ptr < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          ${fields
        .map((fieldDescriptor) => `${(0, field_1.generateFieldDecodeInstruction)(fieldDescriptor, scopeContext)}`)
        .join("\n")}

          default:
            reader.skipType(tag & 7);
            break;
        }
      }

      return message;
    }
  `;
}
function generateMessageFieldsDeclarations(messageDescriptor, fileContext) {
    const fields = getAllFields(messageDescriptor);
    return fields
        .map((fieldDescriptor) => `${(0, field_1.generateFieldName)(fieldDescriptor)}: ${(0, field_1.generateFieldType)(fieldDescriptor, fileContext)}`)
        .join(";\n");
}
function generateMessageConstructor(messageDescriptor, fileContext) {
    const fields = getAllFields(messageDescriptor);
    const constructorParams = fields
        .map((fieldDescriptor) => `${(0, reserved_keywords_1.getSafeName)((0, field_1.generateFieldName)(fieldDescriptor))}: ${(0, field_1.generateFieldType)(fieldDescriptor, fileContext)} = ${(0, field_1.generateFieldDefaultValue)(fieldDescriptor, fileContext)}`)
        .join(",\n");
    const fieldsAssignments = fields
        .map((fieldDescriptor) => `this.${(0, field_1.generateFieldName)(fieldDescriptor)} = ${(0, reserved_keywords_1.getSafeName)((0, field_1.generateFieldName)(fieldDescriptor))}`)
        .join(";\n");
    return `
    constructor(
      ${constructorParams}
    ) {
     ${fieldsAssignments}
    }
  `;
}
function generateHelperMethods(Message, fileContext) {
    const Protobuf = fileContext.registerImport("Protobuf", "as-proto/assembly");
    const encodeHelper = fileContext.registerDefinition(`encode${Message}`);
    const decodeHelper = fileContext.registerDefinition(`decode${Message}`);
    return `
    export function ${encodeHelper}(message: ${Message}): Uint8Array {
      return ${Protobuf}.encode(message, ${Message}.encode);
    }

    export function ${decodeHelper}(buffer: Uint8Array): ${Message} {
      return ${Protobuf}.decode<${Message}>(buffer, ${Message}.decode);
    }
  `;
}
