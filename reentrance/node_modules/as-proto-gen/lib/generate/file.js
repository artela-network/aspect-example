"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getOutputFilePath = exports.generateFiles = void 0;
const message_1 = require("./message");
const plugin_pb_1 = require("google-protobuf/google/protobuf/compiler/plugin_pb");
const file_context_1 = require("../file-context");
const enum_1 = require("./enum");
const header_1 = require("./header");
const assert_1 = __importDefault(require("assert"));
const names_1 = require("../names");
function generateFiles(fileDescriptor, generatorContext, compilerOptions, compilerVersion) {
    const outputFiles = [];
    for (const messageDescriptor of fileDescriptor.getMessageTypeList()) {
        outputFiles.push(...generateMessageFiles(fileDescriptor, messageDescriptor, generatorContext, compilerOptions, compilerVersion));
    }
    for (const enumDescriptor of fileDescriptor.getEnumTypeList()) {
        outputFiles.push(generateEnumFile(fileDescriptor, enumDescriptor, generatorContext, compilerVersion));
    }
    return outputFiles;
}
exports.generateFiles = generateFiles;
function getFilePrefix(fileDescriptor) {
    const filePackage = fileDescriptor.getPackage();
    if (!filePackage) {
        return undefined;
    }
    return filePackage
        .split(".")
        .map((filePackageSegment) => (0, names_1.sanitizeFileName)(filePackageSegment))
        .join("/");
}
function getNestedMessagePrefix(parentMessageDescriptors) {
    if (!parentMessageDescriptors.length) {
        return undefined;
    }
    return parentMessageDescriptors
        .map((messageDescriptor) => {
        const messageName = messageDescriptor.getName();
        assert_1.default.ok(messageName !== undefined);
        return (0, names_1.sanitizeFileName)(messageName);
    })
        .join("/");
}
function getOutputFilePath(fileDescriptor, messageOrEnumDescriptor, parentMessageDescriptors = []) {
    const messageName = messageOrEnumDescriptor.getName();
    assert_1.default.ok(messageName !== undefined);
    const outputFileName = (0, names_1.sanitizeFileName)(`${messageName}.ts`);
    return [
        getFilePrefix(fileDescriptor),
        getNestedMessagePrefix(parentMessageDescriptors),
        outputFileName,
    ].join("/");
}
exports.getOutputFilePath = getOutputFilePath;
function generateMessageFiles(fileDescriptor, messageDescriptor, generatorContext, compilerOptions, compilerVersion, parentMessageDescriptors = []) {
    const messageOptions = messageDescriptor.getOptions();
    if (messageOptions !== undefined && messageOptions.getMapEntry()) {
        // this message type is the entry tuple for a map
        // don't output it - we handle this using built-in Map structure
        return [];
    }
    const outputFile = new plugin_pb_1.CodeGeneratorResponse.File();
    const outputFilePath = getOutputFilePath(fileDescriptor, messageDescriptor, parentMessageDescriptors);
    const outputFileContext = new file_context_1.FileContext(outputFilePath, generatorContext, fileDescriptor);
    const messageCode = (0, message_1.generateMessage)(messageDescriptor, outputFileContext, compilerOptions);
    outputFile.setContent([
        (0, header_1.generateHeaderComment)(compilerVersion),
        outputFileContext.getImportsCode(),
        messageCode,
    ].join("\n"));
    outputFile.setName(outputFilePath);
    const nestedOutputFiles = [];
    for (const nestedMessageDescriptor of messageDescriptor.getNestedTypeList()) {
        nestedOutputFiles.push(...generateMessageFiles(fileDescriptor, nestedMessageDescriptor, generatorContext, compilerOptions, compilerVersion, [...parentMessageDescriptors, messageDescriptor]));
    }
    for (const nestedEnumDescriptor of messageDescriptor.getEnumTypeList()) {
        nestedOutputFiles.push(generateEnumFile(fileDescriptor, nestedEnumDescriptor, generatorContext, compilerVersion, [...parentMessageDescriptors, messageDescriptor]));
    }
    return [outputFile, ...nestedOutputFiles];
}
function generateEnumFile(fileDescriptor, enumDescriptor, generatorContext, compilerVersion, parentMessageDescriptors = []) {
    const outputFile = new plugin_pb_1.CodeGeneratorResponse.File();
    const outputFilePath = getOutputFilePath(fileDescriptor, enumDescriptor, parentMessageDescriptors);
    const outputFileContext = new file_context_1.FileContext(outputFilePath, generatorContext, fileDescriptor);
    const enumCode = (0, enum_1.generateEnum)(enumDescriptor, outputFileContext);
    outputFile.setContent([
        (0, header_1.generateHeaderComment)(compilerVersion),
        outputFileContext.getImportsCode(),
        enumCode,
    ].join("\n"));
    outputFile.setName(outputFilePath);
    return outputFile;
}
